.\" Automatically generated by Pandoc 3.1.1
.\"
.\" Define V font for inline verbatim, using C font in formats
.\" that render this, and otherwise B font.
.ie "\f[CB]x\f[]"x" \{\
. ftr V B
. ftr VI BI
. ftr VB B
. ftr VBI BI
.\}
.el \{\
. ftr V CR
. ftr VI CI
. ftr VB CB
. ftr VBI CBI
.\}
.TH "DUAL-FUNCTION-KEYS" "1" "2020/12/25" "Dual Function Keys" "User Manuals"
.hy
.SH NAME
.PP
interception - dual function keys
.SH DESCRIPTION
.PP
Tap for one key, hold for another.
.PP
Great for modifier keys like: hold for ctrl, tap for delete.
.PP
A hand-saver for those with restricted finger mobility.
.PP
A plugin for interception tools (https://gitlab.com/interception/linux).
.SH QUICK START
.IP "1." 3
Create some dual-function-keys mappings e.g.\ \f[V]/etc/interception/dual-function-keys/my-mappings.yaml\f[R]
.IP
.nf
\f[C]
MAPPINGS:
  - KEY: KEY_BACKSPACE
    TAP: KEY_BACKSPACE
    HOLD: KEY_LEFTSHIFT
  - KEY: KEY_SPACE
    TAP: KEY_SPACE
    HOLD: KEY_RIGHTSHIFT
\f[R]
.fi
.IP "2." 3
Find your keyboard \f[V]libinput list-devices | grep \[dq]\[ha]Device\[dq]\f[R] and create a udevmon configuration e.g.\ \f[V]/etc/interception/udevmon.d/my-udevmon.yaml\f[R]
.IP
.nf
\f[C]
- JOB: \[dq]intercept -g $DEVNODE | dual-function-keys -c /etc/interception/dual-function-keys/my-mappings.yaml | uinput -d $DEVNODE\[dq]
  DEVICE:
    NAME: \[dq]tshort Dactyl-Manuform-6x6.*\[dq]
\f[R]
.fi
.IP "3." 3
Enable udevmon: \f[V]sudo systemctl enable udevmon\f[R]
.IP "4." 3
(Re)start udevmon: \f[V]sudo systemctl restart udevmon\f[R]
.IP "5." 3
Check for problems: \f[V]journalctl -u udevmon\f[R].
No news is good news.
You can safely disregard any \f[V]ignoring /etc/interception/udevmon.yaml, reason: bad file: /etc/interception/udevmon.yaml\f[R] messages.
.SH FUNCTIONALITY
.PP
In these examples we will use the left shift key (LS).
.PP
It is configured to tap for delete (DE) and hold for LS.
.IP
.nf
\f[C]
- KEY: KEY_LEFTSHIFT
  TAP: KEY_DELETE
  HOLD: KEY_LEFTSHIFT
\f[R]
.fi
.SS Tap
.PP
Press and release LS within \f[V]TAP_MILLIS\f[R] (default 200ms) for DE.
.PP
By default, until the tap is complete, we get LS.
See below for other options.
.IP
.nf
\f[C]
                <---------200ms--------->     <---------200ms--------->
keyboard:       LS↓      LS↑                  LS↓                          LS↑
computer sees:  LS↓      LS↑ DE↓ DE↑          LS↓                          LS↑
\f[R]
.fi
.SS Double Tap
.PP
Tap then press again with \f[V]DOUBLE_TAP_MILLIS\f[R] (default 150ms) to hold DE.
.IP
.nf
\f[C]
                             <-------150ms------->
                <---------200ms--------->
keyboard:       LS↓         LS↑             LS↓               LS↑
computer sees:  LS↓         LS↑ DE↓ DE↑     DE↓ ..(repeats).. DE↑
\f[R]
.fi
.PP
You can continue double tapping so long as it is within the \f[V]DOUBLE_TAP_MILLIS\f[R] window.
.SS Consumption
.PP
Press or release another key during the \f[V]TAP_MILLIS\f[R] window and the tap will not occur.
.PP
This is especially useful for modifiers, for instance a quick ctrl-C.
In this example we press the a key during the window.
.PP
Double taps do not apply after consumption; you will need to tap first.
.PP
Mouse and touchpad events (\f[V]EV_REL\f[R] and \f[V]EV_ABS\f[R]) can also consume taps, however you will need to use a Multiple Devices configuration.
.IP
.nf
\f[C]
                                                               <-------150ms------->
                                                 <---------200ms--------->
                                 <-------150ms------->
                <---------200ms--------->
keyboard:       LS↓      a↓  a↑  LS↑             LS↓          LS↑           LS↓
computer sees:  LS↓      a↓  a↑  LS↑             LS↓          LS↑ DE↓ DE↑   DE↓ ..(repeats)..
\f[R]
.fi
.SH INSTALLATION
.SS Package Manager
.PP
[IMAGE: Packaging status (https://repology.org/badge/vertical-allrepos/interception-dual-function-keys.svg)] (https://repology.org/project/interception-dual-function-keys/versions)
.SS From Source
.PP
See runtime dependencies (https://gitlab.com/interception/linux/tools#runtime-dependencies).
.PP
Install Interception Tools (https://gitlab.com/interception/linux/tools) first.
.IP
.nf
\f[C]
git clone https://gitlab.com/interception/linux/plugins/dual-function-keys.git
cd dual-function-keys
make && sudo make install
\f[R]
.fi
.PP
Installation prefix defaults to \f[V]/usr/local\f[R].
This can be overridden in \f[V]config.mk\f[R].
.SH CONFIGURATION
.SS udevmon
.PP
udevmon from interception-tools (https://gitlab.com/interception/linux/tools) is used to launch Dual Function Keys.
See How It Works (https://gitlab.com/interception/linux/tools#how-it-works) for the full story.
.PP
Determine your keyboard\[cq]s name:
.IP
.nf
\f[C]
libinput list-devices | grep \[dq]\[ha]Device\[dq]
\f[R]
.fi
.PP
Alternatively, you can use interception tools\[cq] uinput -p (https://gitlab.com/interception/linux/tools#how-it-works) for more direct device enumeration based on available events (keys) etc.
.PP
Create a new configuration: \f[V]/etc/interception/udevmon.d/my-keyboard.yaml\f[R].
You can create one file per keyboard or one file containing all keyboards.
You can use a regex for the keyboard name.
.IP
.nf
\f[C]
- JOB: \[dq]intercept -g $DEVNODE | dual-function-keys -c </path/to/dual-function-keys.yaml> | uinput -d $DEVNODE\[dq]
  DEVICE:
    NAME: <keyboard name>
\f[R]
.fi
.PP
Example: laptop and dactyl:
.IP
.nf
\f[C]
- JOB: \[dq]intercept -g $DEVNODE | dual-function-keys -c /etc/interception/dual-function-keys/home-row-modifiers.yaml | uinput -d $DEVNODE\[dq]
  DEVICE:
    NAME: \[dq]AT Translated Set 2 keyboard\[dq]
- JOB: \[dq]intercept -g $DEVNODE | dual-function-keys -c /etc/interception/dual-function-keys/dfk.thumb-cluster.yaml | uinput -d $DEVNODE\[dq]
  DEVICE:
    NAME: \[dq]tshort Dactyl-Manuform-6x6.*\[dq]
\f[R]
.fi
.SS dual-function-keys
.PP
This yaml file conventionally resides in \f[V]/etc/interception/dual-function-keys\f[R] and contains the configuration for Dual Function Keys itself.
.PP
You can use raw (integer) keycodes, however it is easier to use the \f[V]#define\f[R]d strings from input-event-codes.h (https://github.com/torvalds/linux/blob/master/include/uapi/linux/input-event-codes.h).
.IP
.nf
\f[C]
# optional
TIMING:
  TAP_MILLISEC: <integer>
  DOUBLE_TAP_MILLISEC: <integer>
  SYNTHETIC_KEYS_PAUSE_MILLISEC: <integer>

# necessary
MAPPINGS:
  - KEY: <integer | string>
    TAP: [ <integer | string>, ... ]
    HOLD: [ <integer | string>, ... ]
    # optional
    HOLD_START: [ AFTER_PRESS | AFTER_RELEASE | BEFORE_CONSUME | BEFORE_CONSUME_OR_RELEASE ]
  - KEY: ...
\f[R]
.fi
.PP
Our example from the previous section looks like:
.IP
.nf
\f[C]
TIMING:
  TAP_MILLISEC: 200
  DOUBLE_TAP_MILLISEC: 150

MAPPINGS:
  - KEY: KEY_LEFTSHIFT
    TAP: KEY_DELETE
    HOLD: KEY_LEFTSHIFT
\f[R]
.fi
.SS Combo Keys
.PP
You can configure the \f[V]TAP\f[R] as a \[lq]combo\[rq], which will press then release multiple keys in order e.g.\ space cadet \f[V](\f[R]:
.IP
.nf
\f[C]
MAPPINGS:
  - KEY: KEY_LEFTSHIFT
    TAP: [ KEY_LEFTSHIFT, KEY_9, ]
    HOLD: KEY_LEFTSHIFT
\f[R]
.fi
.PP
You can configure the \f[V]HOLD\f[R] as a \[lq]combo\[rq], which will press then release multiple keys in order e.g.\ hyper modifier:
.IP
.nf
\f[C]
MAPPINGS:
  - KEY: KEY_TAB
    TAP: KEY_TAB
    HOLD: [ KEY_LEFTCTRL, KEY_LEFTMETA, KEY_LEFTALT, ]
\f[R]
.fi
.PP
By default, there will be a pause of 20ms between keys in the \[lq]combo\[rq].
This may be changed:
.IP
.nf
\f[C]
TIMING:
    SYNTHETIC_KEYS_PAUSE_MILLISEC: 10
\f[R]
.fi
.SS Changing the Behavior of \f[V]HOLD\f[R] Keys
.PP
You can optionally use \f[V]HOLD_START\f[R] to configure the behavior of \f[V]HOLD\f[R] keys.
.SS \f[V]HOLD_START: AFTER_PRESS\f[R]
.PP
If \f[V]HOLD_START\f[R] is unspecified, \f[V]AFTER_PRESS\f[R] or an unrecognized value, the default behaviour will apply.
.SS \f[V]HOLD_START: BEFORE_CONSUME\f[R]
.PP
\f[V]HOLD\f[R] keys are pressed before \f[V]KEY\f[R] is consumed, and released when \f[V]KEY\f[R] is released.
Therefore no extra keys beside \f[V]TAP\f[R] keys are sent when \f[V]KEY\f[R] is tapped, while \f[V]HOLD\f[R] keys can still be used as modifiers.
.IP
.nf
\f[C]
MAPPINGS:
  - KEY: KEY_LEFTSHIFT
    TAP: KEY_DELETE
    HOLD: KEY_LEFTSHIFT
    HOLD_START: BEFORE_CONSUME
\f[R]
.fi
.IP
.nf
\f[C]
                <---------200ms--------->     <---------200ms--------->
keyboard:       LS↓      LS↑                  LS↓                          LS↑
computer sees:           DE↓ DE↑
\f[R]
.fi
.IP
.nf
\f[C]
                                                               <-------150ms------->
                                                 <---------200ms--------->
                                 <-------150ms------->
                <---------200ms--------->
keyboard:       LS↓      a↓  a↑   LS↑             LS↓          LS↑           LS↓
computer sees:       LS↓ a↓  a↑   LS↑                          DE↓ DE↑       DE↓ ..(repeats)..
\f[R]
.fi
.SS \f[V]HOLD_START: BEFORE_CONSUME_OR_RELEASE\f[R]
.PP
The behavior is like \f[V]BEFORE_CONSUME\f[R] except that when \f[V]KEY\f[R] is released and is neither tapped nor consumed before, \f[V]HOLD\f[R] keys are pressed in order and then released in order.
.IP
.nf
\f[C]
MAPPINGS:
  - KEY: KEY_LEFTSHIFT
    TAP: KEY_DELETE
    HOLD: KEY_LEFTSHIFT
    HOLD_START: BEFORE_CONSUME_OR_RELEASE
\f[R]
.fi
.IP
.nf
\f[C]
                <---------200ms--------->     <---------200ms--------->
keyboard:       LS↓      LS↑                  LS↓                          LS↑
computer sees:           DE↓ DE↑                                           LS↓ LS↑
\f[R]
.fi
.SS \f[V]HOLD_START: AFTER_RELEASE\f[R]
.PP
Hold will only start after key release if the TAP_MILLISEC time has been exceded.
This hold start is not affected by any kind of consumption
.IP
.nf
\f[C]
MAPPINGS:
  - KEY: KEY_A
    TAP: KEY_A
    HOLD: [KEY_LEFTSHIFT, KEY_A]
    HOLD_START: AFTER_RELEASE
\f[R]
.fi
.IP
.nf
\f[C]
                <---------200ms--------->     <---------200ms--------->
keyboard:       a↓       a↑                   a↓                           a↑
computer sees:           a↓  a↑                                            A↓ A↑
\f[R]
.fi
.SS Warning
.PP
Do not assign the same modifier to two keys that you intend to press at the same time, as they will interfere with each other.
Use left and right versions of the modifiers e.g.\ alt-tab with space-caps:
.IP
.nf
\f[C]
MAPPINGS:
  - KEY: KEY_CAPSLOCK
    TAP: KEY_TAB
    HOLD: KEY_LEFTALT

  - KEY: KEY_SPACE
    TAP: KEY_SPACE
    HOLD: KEY_RIGHTALT
\f[R]
.fi
.PP
Alternatively, you can use \f[V]HOLD_START: BEFORE_CONSUME\f[R] or \f[V]HOLD_START: BEFORE_CONSUME_OR_RELEASE\f[R] and then assigning the same modifier will be fine:
.IP
.nf
\f[C]
MAPPINGS:
  - KEY: KEY_CAPSLOCK
    TAP: KEY_TAB
    HOLD: KEY_LEFTALT
    HOLD_START: BEFORE_CONSUME_OR_RELEASE

  - KEY: KEY_SPACE
    TAP: KEY_SPACE
    HOLD: KEY_LEFTALT
    HOLD_START: BEFORE_CONSUME_OR_RELEASE
\f[R]
.fi
.SS Multiple Devices
.PP
When using inputs from multiple devices e.g.\ ctrl-scroll it may be necessary to mux (https://gitlab.com/interception/linux/tools#mux) those devices for dual-function-keys to work across these devices e.g.\ scroll consuming ctrl.
.PP
Example udevmon configuration for a mouse and keyboard:
.IP
.nf
\f[C]
- CMD: mux -c dfk -c my-keyboard -c my-mouse
- JOB:
  - mux -i dfk | dual-function-keys -c /etc/interception/dual-function-keys/my-cfg.yaml | mux -o my-keyboard -o my-mouse
  - mux -i my-keyboard | uinput -c /etc/interception/udevmon.d/my-keyboard.yaml
  - mux -i my-mouse | uinput -c /etc/interception/udevmon.d/my-mouse.yaml
- JOB: intercept -g $DEVNODE | mux -o dfk
  DEVICE:
    NAME: AT Translated Set 2 keyboard
    EVENTS:
      EV_KEY: [ KEY_LEFTCTRL ]
- JOB: intercept -g $DEVNODE | mux -o dfk
  DEVICE:
    NAME: Razer Razer Naga Trinity
    EVENTS:
      EV_REL: [REL_WHEEL]
      EV_KEY: [BTN_LEFT]
\f[R]
.fi
.PP
In the above example, \f[V]my-keyboard.yaml\f[R] and \f[V]my-mouse.yaml\f[R] represent the virtual devices that udevmon will create to output events.
They are generated once from the device itself e.g.
.IP
.nf
\f[C]
sudo uinput -p -d /dev/input/by-id/usb-my-keyboard-kbd > my-keyboard.yaml
\f[R]
.fi
.PP
An alternative, if you want to live dangerously (https://gitlab.com/interception/linux/plugins/dual-function-keys/-/issues/31#note_725722450), is to generate the virtual device configuration on the fly e.g.:
.IP
.nf
\f[C]
- CMD: mux -c dfk -c my-keyboard -c my-mouse
- JOB:
  - mux -i dfk | dual-function-keys -c /etc/interception/dual-function-keys/my-cfg.yaml | mux -o my-keyboard -o my-mouse
  - mux -i my-keyboard | uinput -d /dev/input/by-path/my-keyboard-event-kbd
  - mux -i my-mouse | uinput -d /dev/input/by-id/usb-my-mouse-event-mouse
- JOB: intercept -g $DEVNODE | mux -o dfk
  DEVICE:
    LINK: /dev/input/by-path/my-keyboard-event-kbd
- JOB: intercept -g $DEVNODE | mux -o dfk
  DEVICE:
    LINK: /dev/input/by-id/usb-my-mouse-event-mouse
\f[R]
.fi
.SH CAVEATS
.PP
As always, there is a caveat: dual-function-keys operates on raw \f[I]keycodes\f[R], not \f[I]keysyms\f[R], as seen by X11 or Wayland.
.PP
If you have anything modifying the keycode->keysym mapping, such as XKB (https://www.x.org/wiki/XKB/) or xmodmap (https://wiki.archlinux.org/index.php/Xmodmap), be mindful that dual-function-keys operates before them.
.PP
Some common XKB usages that might be found in your X11 configuration:
.IP
.nf
\f[C]
    Option \[dq]XkbModel\[dq] \[dq]pc105\[dq]
    Option \[dq]XKbLayout\[dq] \[dq]us\[dq]
    Option \[dq]XkbVariant\[dq] \[dq]dvp\[dq]
    Option \[dq]XkbOptions\[dq] \[dq]caps:escape\[dq]
\f[R]
.fi
.SH FAQ
.SS I have a new use case. Can you support it?
.PP
Please raise an issue.
.PP
dual-function-keys has been built for my needs.
I will be intrigued to hear your ideas and help you make them happen.
.PP
As usual, PRs are very welcome.
.SS I see you are using q.m.k HHKB mod Keyboard in your udevmon. It uses QMK Firmware (https://qmk.fm/). Why not just use Tap-Hold (https://docs.qmk.fm/#/tap_hold)?
.PP
Good catch!
That does indeed provide the same functionality as dual-function-keys.
Unfortunately there are some drawbacks:
.IP "1." 3
Few keyboards run QMK Firmware.
.IP "2." 3
There are some issues with that functionality, as noted in the documentation Tap-Hold (https://docs.qmk.fm/).
.IP "3." 3
It requires a fast processor in the keyboard.
My unscientific testing with an Ergodox (\[ti]800 scans/sec) and HHKB (\[ti]140) revealed that the slower keyboard is mushy and unuseably inaccurate.
.SS Why not use xcape (https://github.com/alols/xcape)?
.PP
Xcape only provides simple tap/hold functionality.
It appears difficult (impossible?)
to add the remaining functionality using its XTestFakeKeyEvent mechanisms.
.SS My Key Combination Isn\[cq]t Working
.PP
Ensure that your window manager is not intercepting that key combination.
.SS I Don\[cq]t Want Double Tap Functionality
.PP
Set DOUBLE_TAP_MILLISEC to 0.
See Key Combinations, No Double Tap (https://gitlab.com/interception/linux/plugins/dual-function-keys/-/blob/master/doc/examples.md#key-combinations-no-double-tap).
.SS I Just Need Simple Key To Key Mapping
.PP
dual-function-keys does not provide this functionality, please use:
.IP \[bu] 2
Interception tools plugin interception-k2k (https://github.com/zsugabubus/interception-k2k)
.IP \[bu] 2
Standalone keyd (https://github.com/rvaiya/keyd)
.SH CONTRIBUTORS
.PP
Please fork this repo and submit a PR.
.PP
If you are making changes to the documentation, please edit the pandoc flavoured \f[V]dual-function-keys.md\f[R] and run \f[V]make doc\f[R].
Requires docker.
.PP
Please ensure that this \f[V]README.md\f[R] and the man page \f[V]dual-function-keys.1\f[R] has your changes and commit all three.
.PP
You can test the generated man page with \f[V]man -l dual-function-keys.1\f[R]
.PP
As usual, please obey \f[V].editorconfig\f[R].
.SH LICENSE
.PP
.PP
Copyright © 2020 Alexander Courtis
.SH AUTHORS
Alexander Courtis.
